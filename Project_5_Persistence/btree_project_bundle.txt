================================================================================
=== FILE: Makefile
================================================================================

# Basic Makefile for ANSI C B-Tree Library (No Headers)

CC = gcc
CFLAGS = -ansi -Wall -Wpedantic -Werror
# Add -g for debugging, -O2 for optimization, etc.

BTREE_SRC = btree.c storage.c
BTREE_OBJ = $(BTREE_SRC:.c=.o)
TEST_SRC = test_btree.c
TEST_OBJ = $(TEST_SRC:.c=.o)
MAIN_SRC = main.c
MAIN_OBJ = $(MAIN_SRC:.c=.o)
PERF_SRC = perf_btree.c
PERF_OBJ = $(PERF_SRC:.c=.o)

TEST_EXE = test_btree
MAIN_EXE = main_btree
PERF_EXE = perf_btree

all: $(MAIN_EXE) $(TEST_EXE) $(PERF_EXE)

$(MAIN_EXE): $(MAIN_OBJ) $(BTREE_OBJ)
	$(CC) $(CFLAGS) $^ -o $@

$(TEST_EXE): $(TEST_OBJ) $(BTREE_OBJ)
	$(CC) $(CFLAGS) $^ -o $@

$(PERF_EXE): $(PERF_OBJ) $(BTREE_OBJ)
	$(CC) $(CFLAGS) $^ -o $@

# Modified Object file compilation rule - no header dependencies listed
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# CI Target
ci: $(TEST_EXE)
	@echo "Running CI tests..."
	./$(TEST_EXE)
	@echo "CI tests completed successfully."

# Performance Target
perf: $(PERF_EXE)
	@echo "Running performance harness..."
	./$(PERF_EXE)
	@echo "Performance harness completed."

# Clean Target
clean:
	@echo "Cleaning up..."
	rm -f $(BTREE_OBJ) $(TEST_OBJ) $(MAIN_OBJ) $(PERF_OBJ)
	rm -f $(TEST_EXE) $(MAIN_EXE) $(PERF_EXE)
	rm -f *.db *.o core

.PHONY: all clean test ci perf

================================================================================
=== FILE: storage.c
================================================================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h> /* For memset, memcpy, perror */
#include <errno.h>
#include <assert.h> /* For assert */

/* Required struct definition (repeated for no-header build) */
struct Node {
    int n;
    int leaf;
    int *key;
    int *value;
    int *c;
};

/* --- Combined Static Global State (Singleton) --- */
/* Combine core state variables into one struct */
static struct {
    FILE *dataFile;
    int degree;      /* Minimum degree 't' */
    long nodeSize;   /* Calculated size of a node on disk */
} g_storage = { NULL, 0, 0 };

/* Combine statistics counters into one struct */
static struct {
    unsigned long reads;
    unsigned long writes;
    unsigned long allocs;
} g_stats = { 0, 0, 0 };

/* --- Constants --- */
static const int MAGIC_NUMBER = 0xBEEFCAFE;
static const int VERSION = 1;
/* Header Layout: magic(int), version(int), t(int) */
static const long HEADER_SIZE = sizeof(int) * 3;

/* --- Helper Functions --- */

/* Calculates node size based on t */
static long calculate_node_size(int t) {
     assert(t >= 2);
     /* n(int), leaf(int), key[(2t-1)*int], value[(2t-1)*int], c[2t*int] = 6t*sizeof(int) */
     return (long)(6 * t) * sizeof(int);
}

/* Calculates disk offset for a given node address */
static long calculate_offset(int addr) {
    /* Access global state via struct */
    if (g_storage.nodeSize <= 0) {
        fprintf(stderr, "Storage Error: Node size not initialized or invalid.\n");
        exit(EXIT_FAILURE);
    }
    assert(addr >= 0);
    return HEADER_SIZE + (long)addr * g_storage.nodeSize;
}

/* --- API Implementation --- */

int Storage_get_t(void) {
     if (g_storage.dataFile == NULL) {
        fprintf(stderr, "Storage Error: Cannot get t, storage not open.\n");
        exit(EXIT_FAILURE);
     }
     if (g_storage.degree < 2) {
         fprintf(stderr, "Storage Error: Invalid degree t=%d stored internally.\n", g_storage.degree);
         exit(EXIT_FAILURE);
     }
    return g_storage.degree;
}

void Storage_open(const char *fname, int t_user) {
    int stored_t = 0;
    int magic = 0, version = 0;

    if (g_storage.dataFile != NULL) {
        fprintf(stderr, "Storage Error: Storage already open.\n");
        exit(EXIT_FAILURE);
    }

    /* Try opening existing file first */
    g_storage.dataFile = fopen(fname, "r+b");
    if (g_storage.dataFile != NULL) {
        /* File exists */
        if (fseek(g_storage.dataFile, 0, SEEK_SET) != 0) {
            perror("Storage Error: Cannot seek to header (r+b)");
            fclose(g_storage.dataFile); g_storage.dataFile = NULL; exit(EXIT_FAILURE);
        }
        if (fread(&magic, sizeof(int), 1, g_storage.dataFile) != 1 ||
            fread(&version, sizeof(int), 1, g_storage.dataFile) != 1 ||
            fread(&stored_t, sizeof(int), 1, g_storage.dataFile) != 1)
        {
            fprintf(stderr, "Storage Error: Cannot read header from existing file %s\n", fname);
            if (ferror(g_storage.dataFile)) perror("fread error");
            fclose(g_storage.dataFile); g_storage.dataFile = NULL; exit(EXIT_FAILURE);
        }
        if (magic != MAGIC_NUMBER || version != VERSION) {
            fprintf(stderr, "Storage Error: Invalid file format or version (Magic: %x, Version: %d).\n", magic, version);
            fclose(g_storage.dataFile); g_storage.dataFile = NULL; exit(EXIT_FAILURE);
        }
        if (stored_t < 2) {
            fprintf(stderr, "Storage Error: Invalid minimum degree t=%d found in file header.\n", stored_t);
            fclose(g_storage.dataFile); g_storage.dataFile = NULL; exit(EXIT_FAILURE);
        }
        g_storage.degree = stored_t;
        g_storage.nodeSize = calculate_node_size(g_storage.degree);

        /* Check file size consistency */
        {
            long file_size;
            if (fseek(g_storage.dataFile, 0, SEEK_END) != 0) {
                 perror("Storage Error: Cannot seek to end (size check)");
                 fclose(g_storage.dataFile); g_storage.dataFile = NULL; exit(EXIT_FAILURE);
            }
            file_size = ftell(g_storage.dataFile);
             if (file_size < 0) {
                 perror("Storage Error: Cannot get file size (size check)");
                 fclose(g_storage.dataFile); g_storage.dataFile = NULL; exit(EXIT_FAILURE);
            }
            if ((file_size - HEADER_SIZE) % g_storage.nodeSize != 0) {
                fprintf(stderr, "Storage Warning: File size %ld does not align with header (t=%d, nodeSize=%ld).\n",
                        file_size, g_storage.degree, g_storage.nodeSize);
            }
        }

    } else {
        /* File doesn't exist or couldn't open r+b */
        if (errno != ENOENT) {
             perror("Storage Error: Cannot open existing file (r+b)"); exit(EXIT_FAILURE);
        }
        /* Create new file */
        g_storage.dataFile = fopen(fname, "w+b");
        if (g_storage.dataFile == NULL) {
            perror("Storage Error: Cannot create new file (w+b)"); exit(EXIT_FAILURE);
        }
        if (t_user < 2) {
             fprintf(stderr, "Storage Error: Minimum degree t must be >= 2 for new file.\n");
             fclose(g_storage.dataFile); g_storage.dataFile = NULL; remove(fname); exit(EXIT_FAILURE);
        }
        magic = MAGIC_NUMBER; version = VERSION; stored_t = t_user;
        g_storage.degree = t_user;
        g_storage.nodeSize = calculate_node_size(g_storage.degree);
        if (fwrite(&magic, sizeof(int), 1, g_storage.dataFile) != 1 ||
            fwrite(&version, sizeof(int), 1, g_storage.dataFile) != 1 ||
            fwrite(&stored_t, sizeof(int), 1, g_storage.dataFile) != 1)
        {
            fprintf(stderr, "Storage Error: Cannot write header to new file.\n");
            perror("fwrite"); fclose(g_storage.dataFile); g_storage.dataFile = NULL; remove(fname); exit(EXIT_FAILURE);
        }
         if (fflush(g_storage.dataFile) != 0) {
            perror("Storage Error: Cannot flush header");
            fclose(g_storage.dataFile); g_storage.dataFile = NULL; remove(fname); exit(EXIT_FAILURE);
        }
    }

    /* Reset statistics */
    g_stats.reads = 0;
    g_stats.writes = 0;
    g_stats.allocs = 0;
}

void Storage_close(void) {
    if (g_storage.dataFile != NULL) {
        if (fflush(g_storage.dataFile) != 0) {
             perror("Storage Warning: Error flushing file before close");
        }
        if (fclose(g_storage.dataFile) != 0) {
            perror("Storage Warning: Error closing file");
        }
        /* Reset global state */
        g_storage.dataFile = NULL;
        g_storage.degree = 0;
        g_storage.nodeSize = 0;
    }
}

int Storage_empty(void) {
    long file_size;
    if (g_storage.dataFile == NULL) {
        fprintf(stderr, "Storage Error: Storage not open in Storage_empty.\n");
        exit(EXIT_FAILURE);
    }
    if (fflush(g_storage.dataFile) != 0) {
         perror("Storage Warning: fflush failed in Storage_empty");
    }
    if (fseek(g_storage.dataFile, 0, SEEK_END) != 0) {
        perror("Storage Error: fseek failed in Storage_empty"); exit(EXIT_FAILURE);
    }
    file_size = ftell(g_storage.dataFile);
    if (file_size < 0) {
         perror("Storage Error: ftell failed in Storage_empty"); exit(EXIT_FAILURE);
    }
    return (file_size == HEADER_SIZE);
}

/* Storage_alloc: Use efficient fseek/fputc method */
int Storage_alloc(void) {
    long file_size;
    int addr;
    long target_offset;

    if (g_storage.dataFile == NULL) {
        fprintf(stderr, "Storage Error: Storage not open in Storage_alloc.\n"); exit(EXIT_FAILURE);
    }
    if (g_storage.nodeSize <= 0) {
         fprintf(stderr, "Storage Error: Invalid node size in Storage_alloc.\n"); exit(EXIT_FAILURE);
    }
    if (fseek(g_storage.dataFile, 0, SEEK_END) != 0) {
        perror("Storage Error: fseek to end failed in Storage_alloc"); exit(EXIT_FAILURE);
    }
    file_size = ftell(g_storage.dataFile);
     if (file_size < 0) {
         perror("Storage Error: ftell failed in Storage_alloc"); exit(EXIT_FAILURE);
    }
    if ((file_size - HEADER_SIZE) % g_storage.nodeSize != 0) {
        fprintf(stderr, "Storage Error: File size corruption detected before alloc (size %ld, header %ld, nodeSize %ld).\n",
                file_size, HEADER_SIZE, g_storage.nodeSize); exit(EXIT_FAILURE);
    }

    addr = (int)((file_size - HEADER_SIZE) / g_storage.nodeSize);

    /* Efficiently extend file: seek to one byte before end of new block and write null */
    target_offset = calculate_offset(addr) + g_storage.nodeSize - 1;
    if (fseek(g_storage.dataFile, target_offset, SEEK_SET) != 0) {
        perror("Storage Error: fseek to target offset failed in Storage_alloc"); exit(EXIT_FAILURE);
    }
    if (fputc('\0', g_storage.dataFile) == EOF) {
        perror("Storage Error: fputc failed to extend file in Storage_alloc"); exit(EXIT_FAILURE);
    }

    /* Optional: Ensure write is effective */
    /* fflush(g_storage.dataFile); */

    g_stats.allocs++;
    return addr;
}


void Storage_read(int addr, struct Node *x) {
    long offset;
    size_t elements_to_read;
    size_t elements_read;
    int max_keys, max_children;

    if (g_storage.dataFile == NULL) { fprintf(stderr, "Storage Error: Storage not open in Storage_read.\n"); exit(EXIT_FAILURE); }
    if (x == NULL || x->key == NULL || x->value == NULL || x->c == NULL) { fprintf(stderr, "Storage Error: Null node or internal buffer passed to Storage_read.\n"); exit(EXIT_FAILURE); }
    if (g_storage.degree <= 1 || g_storage.nodeSize <= 0) { fprintf(stderr, "Storage Error: Storage not properly initialized (t=%d, nodeSize=%ld).\n", g_storage.degree, g_storage.nodeSize); exit(EXIT_FAILURE); }

    max_keys = 2 * g_storage.degree - 1;
    max_children = 2 * g_storage.degree;
    offset = calculate_offset(addr);

    if (fseek(g_storage.dataFile, offset, SEEK_SET) != 0) { perror("Storage Error: fseek failed in Storage_read"); fprintf(stderr, "Attempted offset: %ld for address %d\n", offset, addr); exit(EXIT_FAILURE); }

    if (fread(&(x->n), sizeof(int), 1, g_storage.dataFile) != 1 || fread(&(x->leaf), sizeof(int), 1, g_storage.dataFile) != 1) {
        fprintf(stderr, "Storage Error: Failed to read node header (n, leaf) at addr %d.\n", addr);
        if (feof(g_storage.dataFile)) fprintf(stderr, " Read past EOF.\n"); else if(ferror(g_storage.dataFile)) perror(" fread error"); else fprintf(stderr, " Short read.\n"); exit(EXIT_FAILURE);
    }
    elements_to_read = max_keys;
    elements_read = fread(x->key, sizeof(int), elements_to_read, g_storage.dataFile); if (elements_read != elements_to_read) goto read_error;
    elements_read = fread(x->value, sizeof(int), elements_to_read, g_storage.dataFile); if (elements_read != elements_to_read) goto read_error;
    elements_to_read = max_children;
    elements_read = fread(x->c, sizeof(int), elements_to_read, g_storage.dataFile); if (elements_read != elements_to_read) goto read_error;

    g_stats.reads++;
    return;

read_error:
    { long current_pos = ftell(g_storage.dataFile); long file_size_on_error = -1;
        fprintf(stderr, "Storage Error: Failed to read node data block at addr %d. Elements read: %lu / Expected: %lu\n", addr, (unsigned long)elements_read, (unsigned long)elements_to_read);
        if (feof(g_storage.dataFile)) fprintf(stderr, " Read past EOF.\n"); else if(ferror(g_storage.dataFile)) perror(" fread error"); else fprintf(stderr, " Short read.\n");
        if (fseek(g_storage.dataFile, 0, SEEK_END) == 0) { file_size_on_error = ftell(g_storage.dataFile); }
        fprintf(stderr, " File size: %ld, Expected offset: %ld, Pos after failed read: %ld\n", file_size_on_error, offset, current_pos);
        exit(EXIT_FAILURE);
    }
}


void Storage_write(int addr, const struct Node *x) {
    long offset;
    size_t elements_to_write;
    size_t elements_written;
    int max_keys, max_children;

    if (g_storage.dataFile == NULL) { fprintf(stderr, "Storage Error: Storage not open in Storage_write.\n"); exit(EXIT_FAILURE); }
    if (x == NULL || x->key == NULL || x->value == NULL || x->c == NULL) { fprintf(stderr, "Storage Error: Null node or internal buffer passed to Storage_write.\n"); exit(EXIT_FAILURE); }
    if (g_storage.degree <= 1 || g_storage.nodeSize <= 0) { fprintf(stderr, "Storage Error: Storage not properly initialized (t=%d, nodeSize=%ld).\n", g_storage.degree, g_storage.nodeSize); exit(EXIT_FAILURE); }

    max_keys = 2 * g_storage.degree - 1;
    max_children = 2 * g_storage.degree;
    offset = calculate_offset(addr);

    if (fseek(g_storage.dataFile, offset, SEEK_SET) != 0) { perror("Storage Error: fseek failed in Storage_write"); fprintf(stderr, "Attempted offset: %ld for address %d\n", offset, addr); exit(EXIT_FAILURE); }

    if (fwrite(&(x->n), sizeof(int), 1, g_storage.dataFile) != 1 || fwrite(&(x->leaf), sizeof(int), 1, g_storage.dataFile) != 1) {
        fprintf(stderr, "Storage Error: Failed to write node header (n, leaf) at addr %d.\n", addr); perror(" fwrite error"); exit(EXIT_FAILURE);
    }
    elements_to_write = max_keys;
    elements_written = fwrite(x->key, sizeof(int), elements_to_write, g_storage.dataFile); if (elements_written != elements_to_write) goto write_error;
    elements_written = fwrite(x->value, sizeof(int), elements_to_write, g_storage.dataFile); if (elements_written != elements_to_write) goto write_error;
    elements_to_write = max_children;
    elements_written = fwrite(x->c, sizeof(int), elements_to_write, g_storage.dataFile); if (elements_written != elements_to_write) goto write_error;

    g_stats.writes++;
    return;

write_error:
    fprintf(stderr, "Storage Error: Failed to write node data block at addr %d. Elements written: %lu / Expected: %lu\n", addr, (unsigned long)elements_written, (unsigned long)elements_to_write);
    perror(" fwrite error"); exit(EXIT_FAILURE);
}


/* --- Statistics Accessors --- */
unsigned long Storage_get_read_count(void) { return g_stats.reads; }
unsigned long Storage_get_write_count(void) { return g_stats.writes; }
unsigned long Storage_get_alloc_count(void) { return g_stats.allocs; }

================================================================================
=== FILE: btree.c
================================================================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h> /* For memmove, memcpy */
#include <limits.h> /* For INT_MIN/MAX */
#include <assert.h> /* For assert */

/* Required Struct Definitions */
struct Node { int n; int leaf; int *key; int *value; int *c; };
struct BTree { int root; int t; };

/* Required Prototypes from storage.c */
void          Storage_open (const char *fname, int t);
void          Storage_close(void);
int           Storage_empty(void);
int           Storage_alloc(void);
void          Storage_read (int addr, struct Node *x);
void          Storage_write(int addr, const struct Node *x);
unsigned long Storage_get_read_count(void);
unsigned long Storage_get_write_count(void);
unsigned long Storage_get_alloc_count(void);
int           Storage_get_t(void);

/* --- Constants --- */
/* Sentinel for unused key/value slots */
#define SENTINEL_VALUE ((int)0xDEADBEEF)
/* Sentinel value for marking a key as deleted */
#define DELETION_SENTINEL ((int)0xDEADDEAD)
/* Sentinel for invalid/unused child address pointers */
#define NULL_ADDR (-1)

/* --- Internal Helper Functions --- */

/* Allocate memory for a Node structure AND its internal arrays */
static struct Node* BTree_allocate_node_mem(int t) {
    struct Node *x = NULL; int max_keys; int max_children; int i;
    assert(t >= 2); max_keys = 2 * t - 1; max_children = 2 * t;
    x = malloc(sizeof(struct Node));
    if (!x) { perror("BTree Memory Error"); exit(EXIT_FAILURE); }
    x->key = malloc(max_keys * sizeof(int));
    x->value = malloc(max_keys * sizeof(int));
    x->c = malloc(max_children * sizeof(int));
    if (!x->key || !x->value || !x->c) {
        perror("BTree Memory Error"); free(x->key); free(x->value); free(x->c); free(x); exit(EXIT_FAILURE); }
    for (i = 0; i < max_keys; ++i) { x->key[i] = SENTINEL_VALUE; x->value[i] = SENTINEL_VALUE; }
    for (i = 0; i < max_children; ++i) { x->c[i] = NULL_ADDR; } /* Use NULL_ADDR */
    x->n = 0; x->leaf = 1; return x;
}

static void BTree_free_node_mem(struct Node *x) {
    if (x) { free(x->key); free(x->value); free(x->c); free(x); }
}

static struct Node* BTree_disk_read(int t, int addr) {
    struct Node *x = BTree_allocate_node_mem(t);
    Storage_read(addr, x); return x;
}

static void BTree_disk_write(int addr, const struct Node *x) {
    Storage_write(addr, x);
}


/* --- CLRS Algorithm Implementations (ANSI C, Single-Node Buffer) --- */

/* Internal search: checks for DELETION_SENTINEL */
static int BTree_search_internal(int t, int addr, int k, int *v_out) {
    struct Node *x = NULL; int found = 0; int i = 0; int child_addr;
    x = BTree_disk_read(t, addr);
    while (i < x->n && k > x->key[i]) { i++; }
    if (i < x->n && k == x->key[i]) {
        if (x->value[i] != DELETION_SENTINEL) {
            *v_out = x->value[i]; found = 1;
        } else { found = 0; /* Marked deleted */ }
    } else if (x->leaf) { found = 0; }
    else { /* Not found or deleted, recurse */
        child_addr = x->c[i];
        BTree_free_node_mem(x); x = NULL; /* Free BEFORE recursion */
        if (child_addr == NULL_ADDR) { /* Use NULL_ADDR */
             fprintf(stderr, "BTree Error: Invalid child address during search (addr=%d, i=%d).\n", addr, i); exit(EXIT_FAILURE);
        }
        return BTree_search_internal(t, child_addr, k, v_out);
    }
    if (x != NULL) { BTree_free_node_mem(x); } return found;
}


/* Internal mark-deleted */
static int BTree_search_and_mark_deleted_internal(int t, int addr, int k) {
    struct Node *x = NULL; int marked = 0; int i = 0; int child_addr;
    x = BTree_disk_read(t, addr);
    while (i < x->n && k > x->key[i]) { i++; }
    if (i < x->n && k == x->key[i]) {
        if (x->value[i] != DELETION_SENTINEL) {
            x->value[i] = DELETION_SENTINEL; BTree_disk_write(addr, x); marked = 1;
        } else { marked = 0; /* Already marked */ }
    } else if (x->leaf) { marked = 0; }
    else { /* Not found or already marked, recurse */
        child_addr = x->c[i];
        BTree_free_node_mem(x); x = NULL; /* Free BEFORE recursion */
        if (child_addr == NULL_ADDR) { /* Use NULL_ADDR */
             fprintf(stderr, "BTree Error: Invalid child address during delete search (addr=%d, i=%d).\n", addr, i); exit(EXIT_FAILURE);
        }
        return BTree_search_and_mark_deleted_internal(t, child_addr, k);
    }
    if (x != NULL) { BTree_free_node_mem(x); } return marked;
}

/* B-TREE-SPLIT-CHILD (Strict Memory Budget Version) */
static void BTree_split_child(int t, int addr_x, int i) {
    /* --- Declarations (ANSI C) --- */
    struct Node *y = NULL; /* Only node buffer needed temporarily */
    int addr_y;
    int addr_z;
    int median_key, median_val;
    int t_minus_1;
    /* Stack buffers for temporary storage */
    int *z_keys = NULL;
    int *z_values = NULL;
    int *z_children = NULL; /* Only if internal node */
    int j;
    int y_is_leaf;

    /* --- Code --- */
    t_minus_1 = t - 1;

    /* 1. Read child node y */
    /* (Assume parent x is NOT in memory yet) */
    /* First, we need the parent temporarily just to get addr_y */
    {
        struct Node *temp_x = BTree_disk_read(t, addr_x);
        addr_y = temp_x->c[i];
        BTree_free_node_mem(temp_x); /* Free parent immediately */
    }
    if (addr_y == NULL_ADDR) { fprintf(stderr, "BTree Error: Invalid child address in parent (addr_x=%d, i=%d) before split.\n", addr_x, i); exit(EXIT_FAILURE); }

    y = BTree_disk_read(t, addr_y); /* Read child */

    /* Sanity check y */
    if (y->n != 2 * t - 1) { fprintf(stderr, "BTree Internal Error: Attempted to split non-full node y (addr=%d, n=%d, t=%d)\n", addr_y, y->n, t); BTree_free_node_mem(y); exit(EXIT_FAILURE); }
    y_is_leaf = y->leaf; /* Store leaf status before modifying y */

    /* 2. Allocate stack buffers (careful with size for large t!) */
    /* Note: Large t might cause stack overflow here. A heap buffer might */
    /* be needed if t is very large, slightly bending the rules. */
    /* Assume t is reasonable for stack allocation here. */
    z_keys = malloc(t_minus_1 * sizeof(int));
    z_values = malloc(t_minus_1 * sizeof(int));
    if (!y_is_leaf) { z_children = malloc(t * sizeof(int)); }
    if (!z_keys || !z_values || (!y_is_leaf && !z_children)) {
        perror("BTree Memory Error: Failed to allocate stack buffers for split");
        free(z_keys); free(z_values); free(z_children); BTree_free_node_mem(y); exit(EXIT_FAILURE);
    }

    /* 3. Copy upper half of y to stack buffers */
    memcpy(z_keys, &y->key[t], t_minus_1 * sizeof(int));
    memcpy(z_values, &y->value[t], t_minus_1 * sizeof(int));
    if (!y_is_leaf) { memcpy(z_children, &y->c[t], t * sizeof(int)); }

    /* 4. Get median key/value (before clearing y) */
    median_key = y->key[t_minus_1];
    median_val = y->value[t_minus_1];

    /* 5. Modify y (lower half) */
    y->n = t_minus_1;
    /* Clear upper half keys/values/children in 'y' with sentinels/NULL_ADDR */
    for (j = t_minus_1; j < 2*t - 1; ++j) { y->key[j] = SENTINEL_VALUE; y->value[j] = SENTINEL_VALUE; }
    if (!y_is_leaf) { for (j = t; j < 2*t; ++j) { y->c[j] = NULL_ADDR; } }

    /* 6. Write modified y back */
    BTree_disk_write(addr_y, y);
    BTree_free_node_mem(y); y = NULL; /* Free y memory */

    /* 7. Allocate disk space and memory for new node z */
    addr_z = Storage_alloc();
    /* Use 'y' variable temporarily for node z */
    y = BTree_allocate_node_mem(t); /* Re-use 'y' pointer for node 'z' */
    y->leaf = y_is_leaf;
    y->n = t_minus_1;

    /* 8. Fill z from stack buffers */
    memcpy(y->key, z_keys, t_minus_1 * sizeof(int));
    memcpy(y->value, z_values, t_minus_1 * sizeof(int));
    if (!y_is_leaf) { memcpy(y->c, z_children, t * sizeof(int)); }

    /* 9. Write z to disk */
    BTree_disk_write(addr_z, y);
    BTree_free_node_mem(y); y = NULL; /* Free z memory */

    /* 10. Free stack buffers */
    free(z_keys); free(z_values); free(z_children);

    /* 11. Read parent x */
    /* Use 'y' variable temporarily for node x */
    y = BTree_disk_read(t, addr_x); /* Re-use 'y' pointer for node 'x' */

    /* 12. Modify parent x */
    /* Make space for new child ptr in x */
    memmove(&y->c[i + 2], &y->c[i + 1], (y->n - i) * sizeof(int));
    y->c[i + 1] = addr_z; /* Link new node z */
    /* Make space for median key/value */
    memmove(&y->key[i + 1], &y->key[i], (y->n - i) * sizeof(int));
    memmove(&y->value[i + 1], &y->value[i], (y->n - i) * sizeof(int));
    y->key[i] = median_key; /* Insert median */
    y->value[i] = median_val;
    y->n = y->n + 1;

    /* 13. Write modified parent x back */
    BTree_disk_write(addr_x, y);
    BTree_free_node_mem(y); y = NULL; /* Free x memory */
}


/* B-TREE-INSERT-NONFULL (Checks for update/undelete) */
static void BTree_insert_nonfull(int t, int addr_x, int k, int v) {
    struct Node *x = NULL; int i; int child_addr; struct Node *child = NULL; int needs_split;
    x = BTree_disk_read(t, addr_x);
    i = 0; while (i < x->n && k > x->key[i]) { i++; }

    if (i < x->n && k == x->key[i]) { /* Key Found: Update */
        x->value[i] = v; BTree_disk_write(addr_x, x); BTree_free_node_mem(x); return;
    }
    /* Key Not Found: Insert */
    if (x->leaf) { /* Case 1: Leaf */
        if (x->n > i) { memmove(&x->key[i + 1], &x->key[i], (x->n - i) * sizeof(int)); memmove(&x->value[i + 1], &x->value[i], (x->n - i) * sizeof(int)); }
        x->key[i] = k; x->value[i] = v; x->n = x->n + 1;
        BTree_disk_write(addr_x, x); BTree_free_node_mem(x);
    } else { /* Case 2: Internal */
        child_addr = x->c[i];
        if (child_addr == NULL_ADDR) { fprintf(stderr, "BTree Error: Invalid child address (insert descent).\n"); BTree_free_node_mem(x); exit(EXIT_FAILURE); }
        BTree_free_node_mem(x); x = NULL; /* Free parent BEFORE child read */
        child = BTree_disk_read(t, child_addr); needs_split = (child->n == 2 * t - 1);
        BTree_free_node_mem(child); child = NULL; /* Free child */
        if (needs_split) {
            BTree_split_child(t, addr_x, i); /* Split handles its own memory */
            /* Re-read parent needed to find correct child after split */
            x = BTree_disk_read(t, addr_x);
            if (k > x->key[i]) { i++; } /* Check key that moved up */
            child_addr = x->c[i];
            BTree_free_node_mem(x); x = NULL; /* Free parent again */
             if (child_addr == NULL_ADDR) { fprintf(stderr, "BTree Error: Invalid child address after split.\n"); exit(EXIT_FAILURE); }
        }
        BTree_insert_nonfull(t, child_addr, k, v); /* Recurse */
    }
}


/* --- Public API Implementation --- */
void BTree_delete(struct BTree *bt, int k); /* Prototype */

struct BTree BTree_open(const char *name, int t_user) {
    struct BTree bt; int root_addr; struct Node *root_node_mem = NULL;
    Storage_open(name, t_user);
    bt.t = Storage_get_t(); bt.root = 0;
    if (Storage_empty()) {
        root_addr = Storage_alloc(); if (root_addr != 0) { fprintf(stderr, "BTree Error: Initial root alloc not addr 0.\n"); Storage_close(); exit(EXIT_FAILURE); }
        root_node_mem = BTree_allocate_node_mem(bt.t); root_node_mem->leaf = 1; root_node_mem->n = 0;
        BTree_disk_write(root_addr, root_node_mem); BTree_free_node_mem(root_node_mem);
    } return bt;
}

void BTree_close(struct BTree *bt) { Storage_close(); bt->root = -1; bt->t = 0; }

/* BTree_put (Strict Memory Budget Root Split Version) */
void BTree_put(const struct BTree *bt, int k, int v) {
    int root_addr = bt->root; int t = bt->t;
    struct Node *r = NULL; /* Only node buffer needed */
    int addr_r_new; int addr_z;
    /* Stack buffers for root split */
    int *z_keys = NULL; int *z_values = NULL; int *z_children = NULL;
    int median_key, median_val;
    int root_is_leaf;
    int j;

    r = BTree_disk_read(t, root_addr);

    if (r->n == 2 * t - 1) { /* Root is full, handle split */
        /* 1. Allocate disk space for the two children */
        addr_r_new = Storage_alloc();
        addr_z = Storage_alloc();

        /* 2. Allocate stack buffers */
        z_keys = malloc((t - 1) * sizeof(int));
        z_values = malloc((t - 1) * sizeof(int));
        root_is_leaf = r->leaf;
        if (!root_is_leaf) { z_children = malloc(t * sizeof(int)); }
        if (!z_keys || !z_values || (!root_is_leaf && !z_children)) {
             perror("BTree Memory Error: Failed stack buffers for root split");
             free(z_keys); free(z_values); free(z_children); BTree_free_node_mem(r); exit(EXIT_FAILURE);
        }

        /* 3. Copy upper half of r to stack buffers */
        memcpy(z_keys, &r->key[t], (t - 1) * sizeof(int));
        memcpy(z_values, &r->value[t], (t - 1) * sizeof(int));
        if (!root_is_leaf) { memcpy(z_children, &r->c[t], t * sizeof(int)); }

        /* 4. Get median key/value */
        median_key = r->key[t - 1];
        median_val = r->value[t - 1];

        /* 5. Modify original root 'r' to become the left child */
        r->n = t - 1;
        /* Clear upper half in 'r' */
        for(j = t - 1; j < 2*t - 1; ++j) { r->key[j] = SENTINEL_VALUE; r->value[j] = SENTINEL_VALUE; }
        if (!root_is_leaf) { for(j = t; j < 2*t; ++j) { r->c[j] = NULL_ADDR; } }

        /* 6. Write modified r to its NEW address */
        BTree_disk_write(addr_r_new, r);
        BTree_free_node_mem(r); r = NULL; /* Free r's memory */

        /* 7. Allocate memory for new sibling z (use 'r' pointer temporarily) */
        r = BTree_allocate_node_mem(t);
        r->leaf = root_is_leaf; r->n = t - 1;

        /* 8. Fill z from stack buffers */
        memcpy(r->key, z_keys, (t - 1) * sizeof(int));
        memcpy(r->value, z_values, (t - 1) * sizeof(int));
        if (!root_is_leaf) { memcpy(r->c, z_children, t * sizeof(int)); }

        /* 9. Write z to its address */
        BTree_disk_write(addr_z, r);
        BTree_free_node_mem(r); r = NULL; /* Free z's memory */

        /* 10. Free stack buffers */
        free(z_keys); free(z_values); free(z_children);

        /* 11. Allocate memory for new root s (use 'r' pointer temporarily) */
        r = BTree_allocate_node_mem(t);
        r->leaf = 0; r->n = 1;
        r->key[0] = median_key; r->value[0] = median_val;
        r->c[0] = addr_r_new; r->c[1] = addr_z;

        /* 12. Write new root s to address 0 */
        BTree_disk_write(root_addr /* 0 */, r);
        BTree_free_node_mem(r); r = NULL; /* Free s's memory */

        /* 13. Insertion must now start from the new root */
        BTree_insert_nonfull(t, root_addr, k, v);

    } else { /* Root is not full */
        BTree_free_node_mem(r); r = NULL;
        BTree_insert_nonfull(t, root_addr, k, v);
    }
}


void BTree_get(const struct BTree *bt, int k, int *v) {
    int root_addr; int t;
    assert(bt != NULL); assert(v != NULL); assert(bt->t >= 2);
    root_addr = bt->root; t = bt->t;
    (void) BTree_search_internal(t, root_addr, k, v);
}

void BTree_delete(struct BTree *bt, int k) {
    int root_addr; int t;
    assert(bt != NULL); assert(bt->t >= 2);
    root_addr = bt->root; t = bt->t;
    (void) BTree_search_and_mark_deleted_internal(t, root_addr, k);
}

================================================================================
=== FILE: test_btree.c
================================================================================

#include <stdio.h>
#include <stdlib.h> /* For rand, srand, malloc, free, exit */
#include <string.h> /* For memcpy */
#include <assert.h>
#include <time.h>   /* For time */
#include <limits.h> /* For INT_MIN, INT_MAX */

/* Required Struct Definitions */
struct Node { int n; int leaf; int *key; int *value; int *c; };
struct BTree { int root; int t; };

/* Required Prototypes from btree.c */
struct BTree BTree_open (const char *name, int t);
void        BTree_close(struct BTree *bt);
void        BTree_put  (const struct BTree *bt, int k, int v);
void        BTree_get  (const struct BTree *bt, int k, int *v);
void        BTree_delete(struct BTree *bt, int k);

/* Required Prototypes from storage.c */
void          Storage_read (int addr, struct Node *x);
unsigned long Storage_get_read_count(void);
unsigned long Storage_get_write_count(void);
unsigned long Storage_get_alloc_count(void);

/* Test file/config */
#define TEST_DB_FILE "test_btree.db"
#define TEST_T 3
#define NUM_RANDOM_INSERTS 1000
#define NUM_RANDOM_DELETES (NUM_RANDOM_INSERTS / 4)
#define NUM_RANDOM_QUERIES (NUM_RANDOM_INSERTS / 2)

/* Sentinel values used by library (must match btree.c) */
#define DELETION_SENTINEL ((int)0xDEADDEAD)
#define UNUSED_SENTINEL   ((int)0xDEADBEEF)
#define NULL_ADDR         (-1)


/* ---- Copied static helpers for invariant checker ---- */
static struct Node* BTree_allocate_node_mem_checker(int t) {
    struct Node *x = NULL; int max_keys; int max_children; int i;
    assert(t >= 2); max_keys = 2 * t - 1; max_children = 2 * t;
    x = malloc(sizeof(struct Node)); if (!x) {perror("Checker Memory Error"); exit(EXIT_FAILURE); }
    x->key = malloc(max_keys * sizeof(int)); x->value = malloc(max_keys * sizeof(int)); x->c = malloc(max_children * sizeof(int));
    if (!x->key || !x->value || !x->c) { perror("Checker Memory Error"); free(x->key); free(x->value); free(x->c); free(x); exit(EXIT_FAILURE); }
    for (i = 0; i < max_keys; ++i) { x->key[i] = UNUSED_SENTINEL; x->value[i] = UNUSED_SENTINEL; }
    for (i = 0; i < max_children; ++i) { x->c[i] = NULL_ADDR; } /* Use NULL_ADDR */
    x->n = 0; x->leaf = 1; return x;
}
static void BTree_free_node_mem_checker(struct Node *x) { if (x) { free(x->key); free(x->value); free(x->c); free(x); } }
static struct Node* BTree_disk_read_checker(int t, int addr) { struct Node *x = BTree_allocate_node_mem_checker(t); Storage_read(addr, x); return x; }
/* --- End of copied helpers --- */

/* --- CLRS Invariant Checks --- */
static int check_node_recursive(int t, int addr, int is_root, int depth, int* tree_height, int min_bound, int max_bound) {
    struct Node *x = NULL; int i; int result = 1; int expected_min_keys; int next_min_bound; int next_max_bound;
    x = BTree_disk_read_checker(t, addr); if (x == NULL) return 0;
    expected_min_keys = is_root ? 1 : t - 1;
    if (x->n == 0 && is_root) { if (!x->leaf) { fprintf(stderr, "Invariant Fail (Addr %d): Non-leaf root n=0.\n", addr); result = 0; goto cleanup; } expected_min_keys = 0; }
    if (!((x->n >= expected_min_keys) && x->n <= 2 * t - 1)) { fprintf(stderr, "Invariant Fail (Addr %d): n=%d out of range [%d, %d]. root=%d, leaf=%d\n", addr, x->n, expected_min_keys, 2 * t - 1, is_root, x->leaf); result = 0; goto cleanup; }
    for (i = 0; i < x->n; ++i) {
        if (!(x->key[i] > min_bound && x->key[i] < max_bound)) { /* Strict bounds for keys within node relative to parent */
            fprintf(stderr, "Invariant Fail (Addr %d): Key[%d]=%d out of bounds (%d, %d).\n", addr, i, x->key[i], min_bound, max_bound); result = 0; goto cleanup; }
        if (i > 0 && !(x->key[i] > x->key[i-1])) { fprintf(stderr, "Invariant Fail (Addr %d): Keys not sorted: key[%d]=%d <= key[%d]=%d.\n", addr, i-1, x->key[i-1], i, x->key[i]); result = 0; goto cleanup; }
        if (x->key[i] == UNUSED_SENTINEL) { fprintf(stderr, "Invariant Fail (Addr %d): Key[%d] is unused sentinel.\n", addr, i); result = 0; goto cleanup; }
        if (x->value[i] == UNUSED_SENTINEL) { fprintf(stderr, "Invariant Fail (Addr %d): Value[%d] is unused sentinel.\n", addr, i); result = 0; goto cleanup; }
    }
    if (x->leaf) { if (*tree_height == -1) { *tree_height = depth; } else if (*tree_height != depth) { fprintf(stderr, "Invariant Fail (Addr %d): Leaf depth %d != %d.\n", addr, depth, *tree_height); result = 0; goto cleanup; } }
    else { /* Internal node */
        if (x->n + 1 <= 0) { fprintf(stderr, "Invariant Fail (Addr %d): Invalid child count %d.\n", addr, x->n + 1); result = 0; goto cleanup; }
        for (i = 0; i <= x->n; ++i) {
             if (x->c[i] == NULL_ADDR) { fprintf(stderr, "Invariant Fail (Addr %d): Child pointer c[%d] is NULL_ADDR.\n", addr, i); result = 0; goto cleanup; }
             next_min_bound = (i == 0)    ? min_bound : x->key[i - 1];
             next_max_bound = (i == x->n) ? max_bound : x->key[i];
             if (i > 0 && i <= x->n && next_min_bound >= next_max_bound) { fprintf(stderr, "Invariant Logic Error (Addr %d): Child bounds invalid min=%d >= max=%d for c[%d].\n", addr, next_min_bound, next_max_bound, i); result = 0; goto cleanup; }
             if (!check_node_recursive(t, x->c[i], 0, depth + 1, tree_height, next_min_bound, next_max_bound)) { result = 0; goto cleanup; }
        }
    }
cleanup: BTree_free_node_mem_checker(x); return result;
}
static void check_btree_invariants(const struct BTree *bt) {
    int tree_height = -1; int is_valid;
    if (bt == NULL || bt->t < 2 || bt->root != 0) { fprintf(stderr, "Invariant Fail: BTree struct invalid (t=%d, root=%d).\n", bt ? bt->t : -1, bt ? bt->root : -1); assert(0); }
    is_valid = check_node_recursive(bt->t, bt->root, 1, 0, &tree_height, INT_MIN, INT_MAX);
    if (!is_valid) { fprintf(stderr, "!!! B-Tree Invariants VIOLATED !!!\n"); assert(0); }
}

/* --- Test Helper Functions (Use stdlib rand) --- */
void test_shuffle(int *array, size_t n) {
    size_t i; size_t j; int temp;
    if (n > 1) {
        for (i = 0; i < n - 1; i++) {
            /* rand() % (N-i) gives range 0 to N-i-1. Add i for range i to N-1 */
            j = i + rand() % (n - i);
            temp = array[j]; array[j] = array[i]; array[i] = temp;
        }
    }
}

/* --- Test Cases --- */
void test_basic_crud() {
    struct BTree bt; int val; int not_found_marker = -999;
    printf("--- Test Basic CRUD ---\n"); remove(TEST_DB_FILE);
    bt = BTree_open(TEST_DB_FILE, TEST_T); check_btree_invariants(&bt);
    printf("Inserting key=10, val=100\n"); BTree_put(&bt, 10, 100); check_btree_invariants(&bt);
    val = not_found_marker; BTree_get(&bt, 10, &val); printf("Got val for key=10: %d\n", val); assert(val == 100);
    printf("Inserting key=20, val=200\n"); BTree_put(&bt, 20, 200); check_btree_invariants(&bt);
    printf("Updating key=10, val=101\n"); BTree_put(&bt, 10, 101); check_btree_invariants(&bt);
    val = not_found_marker; BTree_get(&bt, 10, &val); printf("Got updated val for key=10: %d\n", val); assert(val == 101);
    val = not_found_marker; BTree_get(&bt, 20, &val); printf("Got val for key=20: %d\n", val); assert(val == 200);
    val = not_found_marker; BTree_get(&bt, 30, &val); printf("Got val for key=30 (not found): %d\n", val); assert(val == not_found_marker);
    BTree_close(&bt); printf("Basic CRUD Passed.\n");
}

void test_node_split() {
    struct BTree bt; int i; int num_keys_to_split; int not_found_marker = -999; int val;
    printf("--- Test Node Split (Requires t=%d) ---\n", TEST_T); if (TEST_T < 2) { printf("Skipping split test, t must be >= 2\n"); return; }
    remove(TEST_DB_FILE); bt = BTree_open(TEST_DB_FILE, TEST_T); num_keys_to_split = 2 * TEST_T - 1;
    printf("Inserting %d keys to force a split...\n", num_keys_to_split);
    for (i = 1; i <= num_keys_to_split; ++i) { BTree_put(&bt, i * 10, i * 100); check_btree_invariants(&bt); }
    printf("Root node should be full now (n=%d).\n", num_keys_to_split);
    printf("Inserting one more key (%d) to trigger root split...\n", (num_keys_to_split + 1) * 10);
    BTree_put(&bt, (num_keys_to_split + 1) * 10, (num_keys_to_split + 1) * 100); check_btree_invariants(&bt);
    printf("Root should have split. Checking keys...\n");
    for (i = 1; i <= num_keys_to_split + 1; ++i) { val = not_found_marker; BTree_get(&bt, i * 10, &val); if (val != i * 100) { fprintf(stderr, " Split test failed: Key %d not found or wrong value (%d != %d)\n", i*10, val, i*100); } assert(val == i * 100); }
    BTree_close(&bt); printf("Node Split Test Passed.\n");
}

void test_random_inserts_and_queries() {
    struct BTree bt; int *keys = NULL; int *values = NULL; int i; int j; int k; int unique; int not_found_marker = -9999; time_t start, end; int val;
    printf("--- Test Random Inserts/Queries (N=%d, T=%d) ---\n", NUM_RANDOM_INSERTS, TEST_T); remove(TEST_DB_FILE);
    bt = BTree_open(TEST_DB_FILE, TEST_T); keys = malloc(NUM_RANDOM_INSERTS * sizeof(int)); values = malloc(NUM_RANDOM_INSERTS * sizeof(int)); assert(keys && values);
    srand((unsigned int)time(NULL)); /* Use srand */
    printf("Generating %d unique random keys...\n", NUM_RANDOM_INSERTS);
    for (i = 0; i < NUM_RANDOM_INSERTS; ++i) {
        do { unique = 1; k = rand() % (NUM_RANDOM_INSERTS * 10); /* Use rand */
            for (j = 0; j < i; ++j) { if (keys[j] == k) { unique = 0; break; } } if (!unique) continue;
        } while (0);
        keys[i] = k; values[i] = k + 1000000;
    }
    printf("Inserting %d keys...\n", NUM_RANDOM_INSERTS); start = clock();
    for (i = 0; i < NUM_RANDOM_INSERTS; ++i) {
        BTree_put(&bt, keys[i], values[i]);
        if ((i + 1) % (NUM_RANDOM_INSERTS / 10) == 0) { printf("  Inserted %d / %d\n", i + 1, NUM_RANDOM_INSERTS); check_btree_invariants(&bt); }
    }
    end = clock(); check_btree_invariants(&bt); printf("Insertion time: %.2f seconds\n", (double)(end - start) / CLOCKS_PER_SEC);
    printf("Querying %d random inserted keys...\n", NUM_RANDOM_QUERIES); test_shuffle(keys, NUM_RANDOM_INSERTS); start = clock();
    for (i = 0; i < NUM_RANDOM_QUERIES; ++i) {
        val = not_found_marker; BTree_get(&bt, keys[i], &val);
        if (val != keys[i] + 1000000) { fprintf(stderr, " Random test failed: Key %d not found or wrong value (%d != %d)\n", keys[i], val, keys[i] + 1000000); } assert(val == keys[i] + 1000000);
        if ((i + 1) % (NUM_RANDOM_QUERIES / 10) == 0) { printf("  Queried %d / %d\n", i + 1, NUM_RANDOM_QUERIES); }
    }
    end = clock(); printf("Query time: %.2f seconds\n", (double)(end - start) / CLOCKS_PER_SEC);
    val = not_found_marker; BTree_get(&bt, -1, &val); assert(val == not_found_marker);
    printf("Storage Stats: Reads=%lu, Writes=%lu, Allocs=%lu\n", Storage_get_read_count(), Storage_get_write_count(), Storage_get_alloc_count());
    BTree_close(&bt); free(keys); free(values); printf("Random Inserts/Queries Test Passed.\n");
}

void test_delete_and_update() {
    struct BTree bt; int i; int keys_to_use[] = {10, 20, 5, 15, 25, 30, 3, 8, 12, 18, 22, 28}; int num_keys = sizeof(keys_to_use) / sizeof(keys_to_use[0]);
    int keys_to_delete[] = {15, 3, 30, 99}; int num_to_delete = sizeof(keys_to_delete) / sizeof(keys_to_delete[0]);
    int val; int not_found_marker = -555; int current_key; int is_deleted; int j;
    printf("--- Test Delete and Update (Marking) ---\n"); remove(TEST_DB_FILE);
    bt = BTree_open(TEST_DB_FILE, TEST_T); check_btree_invariants(&bt);
    printf("Inserting initial keys...\n"); for (i = 0; i < num_keys; ++i) { BTree_put(&bt, keys_to_use[i], keys_to_use[i] * 10); check_btree_invariants(&bt); }
    printf("Deleting selected keys...\n"); for (i = 0; i < num_to_delete; ++i) { printf(" Deleting %d\n", keys_to_delete[i]); BTree_delete(&bt, keys_to_delete[i]); check_btree_invariants(&bt); val = not_found_marker; BTree_get(&bt, keys_to_delete[i], &val); assert(val == not_found_marker); }
    printf("Verifying remaining keys and deleted keys...\n"); for (i = 0; i < num_keys; ++i) { current_key = keys_to_use[i]; is_deleted = 0; val = not_found_marker; BTree_get(&bt, current_key, &val); for (j = 0; j < num_to_delete; ++j) { if (current_key == keys_to_delete[j]) { is_deleted = 1; break; } } if (is_deleted) { assert(val == not_found_marker); } else { assert(val == current_key * 10); } }
    printf("Attempting to delete already deleted key (should be no-op)...\n"); BTree_delete(&bt, 15); check_btree_invariants(&bt); val = not_found_marker; BTree_get(&bt, 15, &val); assert(val == not_found_marker);
    printf("Re-inserting/Updating a deleted key...\n"); BTree_put(&bt, 15, 155); check_btree_invariants(&bt); val = not_found_marker; BTree_get(&bt, 15, &val); printf(" Got val for re-inserted key=15: %d\n", val); assert(val == 155);
    printf("Updating a non-deleted key...\n"); BTree_put(&bt, 20, 202); check_btree_invariants(&bt); val = not_found_marker; BTree_get(&bt, 20, &val); assert(val == 202);
    BTree_close(&bt); printf("Delete and Update Test Passed.\n");
}

int main() {
    /* Seed random number generator ONCE */
    srand((unsigned int)time(NULL));

    printf("Starting B-Tree Test Suite...\n");
    test_basic_crud(); printf("\n");
    test_node_split(); printf("\n");
    test_random_inserts_and_queries(); printf("\n");
    test_delete_and_update(); printf("\n");
    printf("All B-Tree Tests Passed!\n");
    return 0;
}

================================================================================
=== FILE: perf_btree.c
================================================================================

#include <stdio.h>
#include <stdlib.h> /* For rand, srand, malloc, free, exit, atoi */
#include <time.h>   /* For time */
#include <string.h> /* For memcpy, sprintf */
#include <assert.h>

/* Required Struct Definitions */
struct Node { int n; int leaf; int *key; int *value; int *c; };
struct BTree { int root; int t; };

/* Required Prototypes from btree.c */
struct BTree BTree_open (const char *name, int t);
void        BTree_close(struct BTree *bt);
void        BTree_put  (const struct BTree *bt, int k, int v);
void        BTree_get  (const struct BTree *bt, int k, int *v);

/* Required Prototypes from storage.c */
unsigned long Storage_get_read_count(void);
unsigned long Storage_get_write_count(void);
unsigned long Storage_get_alloc_count(void);

#define PERF_DB_FILE_PREFIX "perf_btree_t"
#define NUM_KEYS 100000
#define NUM_QUERIES 10000

/* Use standard rand/srand */

int main(int argc, const char *argv[]) {
    /* --- Declarations at top (ANSI C) --- */
    int min_t = 4; int max_t = 128; int step_t = 2;
    int num_keys = NUM_KEYS; int num_queries = NUM_QUERIES;
    int *keys_to_insert = NULL; int *keys_to_query = NULL;
    char db_filename[256]; int i; int j; int t; int k; int unique;
    size_t shuffle_idx; int tmp; struct BTree bt; clock_t start, end;
    double insert_time, query_time;
    unsigned long reads_start_ins, writes_start_ins, allocs_start_ins;
    unsigned long reads_end_ins, writes_end_ins, allocs_end_ins;
    unsigned long reads_start_qry, writes_start_qry, allocs_start_qry;
    unsigned long reads_end_qry, writes_end_qry, allocs_end_qry; int val;

    /* --- Code --- */
    printf("Performance Harness\n");
    printf("Usage: %s [num_keys] [num_queries] [min_t] [max_t] [step_t]\n", argv[0]);
    printf("Defaults: N=%d, Q=%d, min_t=%d, max_t=%d, step=x%d\n\n",
           NUM_KEYS, NUM_QUERIES, min_t, max_t, step_t);

    /* --- Argument Parsing (Fixed Indentation) --- */
    if (argc > 1) num_keys = atoi(argv[1]);
    if (argc > 2) num_queries = atoi(argv[2]);
    if (argc > 3) min_t = atoi(argv[3]);
    if (argc > 4) max_t = atoi(argv[4]);
    if (argc > 5) step_t = atoi(argv[5]);
    /* --- End Argument Parsing Fix --- */

    if (num_keys <= 0 || num_queries <= 0 || num_queries > num_keys || min_t < 2 || max_t < min_t || step_t < 1) {
        fprintf(stderr, "Invalid arguments.\n"); return 1;
    }

    keys_to_insert = malloc(num_keys * sizeof(int)); keys_to_query = malloc(num_queries * sizeof(int));
    if (!keys_to_insert || !keys_to_query) { perror("Failed to allocate key arrays"); return 1; }

    printf("Generating %d unique random keys for insertion...\n", num_keys);
    srand((unsigned int)time(NULL)); /* Seed rand once */
    for (i = 0; i < num_keys; ++i) {
        do { unique = 1; k = rand() % (num_keys * 10); /* Use rand */
            for (j = 0; j < i; ++j) { if (keys_to_insert[j] == k) { unique = 0; break; } } if (!unique) continue;
        } while(0); keys_to_insert[i] = k;
    }
    printf("Generating %d keys for querying...\n", num_queries);
    for(i=0; i<num_keys; ++i) { shuffle_idx = (size_t)i + rand() % (num_keys - i); tmp = keys_to_insert[shuffle_idx]; keys_to_insert[shuffle_idx] = keys_to_insert[i]; keys_to_insert[i] = tmp; }
    memcpy(keys_to_query, keys_to_insert, num_queries * sizeof(int));
    for(i=0; i<num_keys; ++i) { shuffle_idx = (size_t)i + rand() % (num_keys - i); tmp = keys_to_insert[shuffle_idx]; keys_to_insert[shuffle_idx] = keys_to_insert[i]; keys_to_insert[i] = tmp; }

    printf("------------------------------------------------------------------------------------------------------------------------------\n");
    printf("| %4s | %12s | %12s | %10s | %10s | %10s | %12s | %12s | %10s | %10s | %10s |\n", "T", "Ins Time (s)", "Ins Ops/s", "Ins Reads", "Ins Writes", "Ins Allocs", "Qry Time (s)", "Qry Ops/s", "Qry Reads", "Qry Writes", "Qry Allocs");
    printf("------------------------------------------------------------------------------------------------------------------------------\n");

    for (t = min_t; t <= max_t; t = (step_t == 1 ? t + 1 : t * step_t)) {
        sprintf(db_filename, "%s%d.db", PERF_DB_FILE_PREFIX, t); remove(db_filename);
        bt = BTree_open(db_filename, t);
        reads_start_ins = Storage_get_read_count(); writes_start_ins = Storage_get_write_count(); allocs_start_ins = Storage_get_alloc_count();
        start = clock(); for (i = 0; i < num_keys; ++i) { BTree_put(&bt, keys_to_insert[i], keys_to_insert[i] + 1); } end = clock();
        reads_end_ins = Storage_get_read_count(); writes_end_ins = Storage_get_write_count(); allocs_end_ins = Storage_get_alloc_count(); insert_time = (double)(end - start) / CLOCKS_PER_SEC;
        reads_start_qry = Storage_get_read_count(); writes_start_qry = Storage_get_write_count(); allocs_start_qry = Storage_get_alloc_count();
        start = clock(); for (i = 0; i < num_queries; ++i) { val = -1; BTree_get(&bt, keys_to_query[i], &val); if (val != keys_to_query[i] + 1) { fprintf(stderr, "WARN: Query failed for key %d (t=%d, val=%d)\n", keys_to_query[i], t, val); } } end = clock();
        reads_end_qry = Storage_get_read_count(); writes_end_qry = Storage_get_write_count(); allocs_end_qry = Storage_get_alloc_count(); query_time = (double)(end - start) / CLOCKS_PER_SEC;
        BTree_close(&bt);
        printf("| %4d | %12.4f | %12.1f | %10lu | %10lu | %10lu | %12.4f | %12.1f | %10lu | %10lu | %10lu |\n", t, insert_time, insert_time > 0 ? (double)num_keys / insert_time : 0.0, reads_end_ins - reads_start_ins, writes_end_ins - writes_start_ins, allocs_end_ins - allocs_start_ins, query_time, query_time > 0 ? (double)num_queries / query_time : 0.0, reads_end_qry - reads_start_qry, writes_end_qry - writes_start_qry, allocs_end_qry - allocs_start_qry);
        /* remove(db_filename); */
    }
    printf("------------------------------------------------------------------------------------------------------------------------------\n");

    free(keys_to_insert); free(keys_to_query); printf("Performance Harness Finished.\n"); return 0;
}

================================================================================
=== FILE: main.c
================================================================================

#include <stdio.h>
#include <stdlib.h> /* For rand, srand, malloc, free, exit, atoi */
#include <time.h>   /* For time */
#include <string.h> /* For memcpy */
#include <assert.h>

/* Required Struct Definitions */
struct Node { int n; int leaf; int *key; int *value; int *c; };
struct BTree { int root; int t; };

/* Required Prototypes from btree.c */
struct BTree BTree_open (const char *name, int t);
void        BTree_close(struct BTree *bt);
void        BTree_put  (const struct BTree *bt, int k, int v);
void        BTree_get  (const struct BTree *bt, int k, int *v);

/* Required Prototypes from storage.c */
unsigned long Storage_get_read_count(void);
unsigned long Storage_get_write_count(void);
unsigned long Storage_get_alloc_count(void);

#define EXAMPLE_DB_FILE "main_example.db"
#define EXAMPLE_T 170
#define NUM_KEYS_TO_INSERT 100000
#define NUM_KEYS_TO_QUERY 10000

/* Use standard rand/srand */

int main() {
    struct BTree bt; int *keys_inserted = NULL; int *keys_to_query = NULL;
    clock_t start, end; double cpu_time_used;
    unsigned long initial_reads, initial_writes, initial_allocs;
    unsigned long final_reads, final_writes, final_allocs;
    int i; int j; int k; int duplicate; int found_count = 0;
    int not_found_marker = -7777; int value; size_t shuffle_idx; int tmp;

    printf("B-Tree Usage Example\n"); printf("Database file: %s\n", EXAMPLE_DB_FILE);
    printf("Minimum degree t: %d\n", EXAMPLE_T); printf("Keys to insert: %d\n", NUM_KEYS_TO_INSERT);
    printf("Keys to query: %d\n", NUM_KEYS_TO_QUERY);

    keys_inserted = malloc(NUM_KEYS_TO_INSERT * sizeof(int)); keys_to_query = malloc(NUM_KEYS_TO_QUERY * sizeof(int));
    if (!keys_inserted || !keys_to_query) { perror("Failed to allocate memory for keys"); return 1; }

    printf("Generating %d unique random keys...\n", NUM_KEYS_TO_INSERT);
    srand((unsigned int)time(NULL)); /* Seed rand once */
    for (i = 0; i < NUM_KEYS_TO_INSERT; ++i) {
        do { k = (rand() << 15) | rand(); /* Use rand */ if (k < 0) k = -k; duplicate = 0;
            for (j = 0; j < i; ++j) { if (keys_inserted[j] == k) { duplicate = 1; break; } } if (duplicate) continue;
        } while (0); keys_inserted[i] = k;
    }
    printf("Keys generated.\n");
    for(i=0; i<NUM_KEYS_TO_INSERT; ++i) { shuffle_idx = (size_t)i + rand() % (NUM_KEYS_TO_INSERT - i); tmp = keys_inserted[shuffle_idx]; keys_inserted[shuffle_idx] = keys_inserted[i]; keys_inserted[i] = tmp; }
    memcpy(keys_to_query, keys_inserted, NUM_KEYS_TO_QUERY * sizeof(int));
    for(i=0; i<NUM_KEYS_TO_INSERT; ++i) { shuffle_idx = (size_t)i + rand() % (NUM_KEYS_TO_INSERT - i); tmp = keys_inserted[shuffle_idx]; keys_inserted[shuffle_idx] = keys_inserted[i]; keys_inserted[i] = tmp; }

    printf("Opening B-tree file '%s' with t=%d...\n", EXAMPLE_DB_FILE, EXAMPLE_T); remove(EXAMPLE_DB_FILE);
    bt = BTree_open(EXAMPLE_DB_FILE, EXAMPLE_T); initial_reads = Storage_get_read_count(); initial_writes = Storage_get_write_count(); initial_allocs = Storage_get_alloc_count(); printf("B-tree opened.\n");
    printf("Inserting %d keys...\n", NUM_KEYS_TO_INSERT); start = clock();
    for (i = 0; i < NUM_KEYS_TO_INSERT; ++i) { BTree_put(&bt, keys_inserted[i], keys_inserted[i] * 2); if ((i + 1) % (NUM_KEYS_TO_INSERT / 10) == 0) { printf("  Inserted %d / %d\n", i + 1, NUM_KEYS_TO_INSERT); } }
    end = clock(); cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC; printf("Insertion finished in %.2f seconds.\n", cpu_time_used);
    printf("Querying %d keys...\n", NUM_KEYS_TO_QUERY); start = clock();
    for (i = 0; i < NUM_KEYS_TO_QUERY; ++i) { value = not_found_marker; BTree_get(&bt, keys_to_query[i], &value); if (value == keys_to_query[i] * 2) { found_count++; } else { fprintf(stderr, "Verification failed: Key %d not found or wrong value %d (expected %d)\n", keys_to_query[i], value, keys_to_query[i] * 2); } }
    end = clock(); cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC; printf("Querying finished in %.2f seconds.\n", cpu_time_used); printf("Verified %d out of %d keys.\n", found_count, NUM_KEYS_TO_QUERY); assert(found_count == NUM_KEYS_TO_QUERY);
    final_reads = Storage_get_read_count(); final_writes = Storage_get_write_count(); final_allocs = Storage_get_alloc_count();
    printf("Closing B-tree...\n"); BTree_close(&bt); printf("B-tree closed.\n");
    printf("\n--- Storage Statistics ---\n"); printf("Total Reads: %lu\n", final_reads); printf("Total Writes: %lu\n", final_writes); printf("Total Allocs: %lu\n", final_allocs);
    printf("Reads during operations: %lu\n", final_reads - initial_reads); printf("Writes during operations: %lu\n", final_writes - initial_writes); printf("Allocs during operations: %lu\n", final_allocs - initial_allocs);
    free(keys_inserted); free(keys_to_query); printf("\nExample finished successfully.\n"); return 0;
}

